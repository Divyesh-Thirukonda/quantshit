"""
Base strategy classes and interfaces.
"""
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from src.data.providers import MarketData, OrderBook


class SignalType(Enum):
    """Signal types."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


class StrategyStatus(Enum):
    """Strategy status."""
    ACTIVE = "active"
    PAUSED = "paused"
    STOPPED = "stopped"
    ERROR = "error"


@dataclass
class TradingSignal:
    """Trading signal generated by strategy."""
    strategy_name: str
    market_id: str
    platform: str
    signal_type: SignalType
    outcome: str  # "yes" or "no"
    confidence: float  # 0.0 to 1.0
    suggested_size: float
    price_target: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    metadata: Optional[Dict[str, Any]] = None
    timestamp: datetime = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.utcnow()


@dataclass
class ArbitrageOpportunity:
    """Arbitrage opportunity."""
    opportunity_id: str
    strategy_name: str
    opportunity_type: str  # "cross_platform" or "correlation"
    markets: List[Dict[str, Any]]  # List of market info
    expected_profit: float
    required_capital: float
    confidence_score: float
    expiry_time: Optional[datetime] = None
    metadata: Optional[Dict[str, Any]] = None
    timestamp: datetime = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.utcnow()


class BaseStrategy(ABC):
    """Base class for all trading strategies."""
    
    def __init__(self, name: str, config: Optional[Dict[str, Any]] = None):
        self.name = name
        self.config = config or {}
        self.status = StrategyStatus.ACTIVE
        self.position_size = 0.0
        self.performance_metrics = {}
        self.last_update = datetime.utcnow()
    
    @abstractmethod
    async def analyze_markets(
        self,
        markets: Dict[str, List[MarketData]],
        order_books: Optional[Dict[str, OrderBook]] = None
    ) -> List[TradingSignal]:
        """
        Analyze markets and generate trading signals.
        
        Args:
            markets: Dictionary of platform -> list of markets
            order_books: Optional order book data
            
        Returns:
            List of trading signals
        """
        pass
    
    @abstractmethod
    async def find_opportunities(
        self,
        markets: Dict[str, List[MarketData]],
        order_books: Optional[Dict[str, OrderBook]] = None
    ) -> List[ArbitrageOpportunity]:
        """
        Find arbitrage opportunities.
        
        Args:
            markets: Dictionary of platform -> list of markets
            order_books: Optional order book data
            
        Returns:
            List of arbitrage opportunities
        """
        pass
    
    def update_position(self, market_id: str, platform: str, size_change: float) -> None:
        """Update position size."""
        self.position_size += size_change
        self.last_update = datetime.utcnow()
    
    def get_status(self) -> Dict[str, Any]:
        """Get strategy status and metrics."""
        return {
            "name": self.name,
            "status": self.status.value,
            "position_size": self.position_size,
            "last_update": self.last_update,
            "performance_metrics": self.performance_metrics,
            "config": self.config
        }
    
    def pause(self) -> None:
        """Pause the strategy."""
        self.status = StrategyStatus.PAUSED
    
    def resume(self) -> None:
        """Resume the strategy."""
        self.status = StrategyStatus.ACTIVE
    
    def stop(self) -> None:
        """Stop the strategy."""
        self.status = StrategyStatus.STOPPED
    
    def set_error(self, error_message: str) -> None:
        """Set strategy to error state."""
        self.status = StrategyStatus.ERROR
        self.performance_metrics["last_error"] = error_message
        self.performance_metrics["error_time"] = datetime.utcnow()


class StrategyManager:
    """Manages multiple trading strategies."""
    
    def __init__(self):
        self.strategies: Dict[str, BaseStrategy] = {}
        self.active_opportunities: List[ArbitrageOpportunity] = []
        self.signal_history: List[TradingSignal] = []
    
    def add_strategy(self, strategy: BaseStrategy) -> None:
        """Add a strategy to the manager."""
        self.strategies[strategy.name] = strategy
    
    def remove_strategy(self, strategy_name: str) -> None:
        """Remove a strategy from the manager."""
        if strategy_name in self.strategies:
            del self.strategies[strategy_name]
    
    def get_strategy(self, strategy_name: str) -> Optional[BaseStrategy]:
        """Get a strategy by name."""
        return self.strategies.get(strategy_name)
    
    async def run_all_strategies(
        self,
        markets: Dict[str, List[MarketData]],
        order_books: Optional[Dict[str, OrderBook]] = None
    ) -> Tuple[List[TradingSignal], List[ArbitrageOpportunity]]:
        """
        Run all active strategies.
        
        Returns:
            Tuple of (signals, opportunities)
        """
        all_signals = []
        all_opportunities = []
        
        for strategy in self.strategies.values():
            if strategy.status == StrategyStatus.ACTIVE:
                try:
                    # Get signals
                    signals = await strategy.analyze_markets(markets, order_books)
                    all_signals.extend(signals)
                    
                    # Get opportunities
                    opportunities = await strategy.find_opportunities(markets, order_books)
                    all_opportunities.extend(opportunities)
                    
                except Exception as e:
                    strategy.set_error(str(e))
        
        # Store signals in history
        self.signal_history.extend(all_signals)
        
        # Update active opportunities
        self.active_opportunities = all_opportunities
        
        return all_signals, all_opportunities
    
    def get_all_status(self) -> Dict[str, Dict[str, Any]]:
        """Get status of all strategies."""
        return {name: strategy.get_status() for name, strategy in self.strategies.items()}
    
    def pause_all(self) -> None:
        """Pause all strategies."""
        for strategy in self.strategies.values():
            strategy.pause()
    
    def resume_all(self) -> None:
        """Resume all strategies."""
        for strategy in self.strategies.values():
            if strategy.status == StrategyStatus.PAUSED:
                strategy.resume()
    
    def stop_all(self) -> None:
        """Stop all strategies."""
        for strategy in self.strategies.values():
            strategy.stop()